Redux: A third   party library for managing global state in web applications.
Compatibility: Can be used with any framework or Vanilla JavaScript, but often associated with React via the `react   redux` library.

Key Concepts

Global Store: All global state in the application is stored in one globally accessible store.
Actions: Updates to the store are made using actions.

Comparison with useReducer Hook

Similar Mechanism: Both Redux and `useReducer` involve updating state by dispatching actions.
Prerequisite: Understanding `useReducer` helps in learning Redux.

State Update Process

Redux Store: Centralized container for all global state.
Reducers: Pure functions in the store that calculate the next state based on the action dispatched and current state.
Re   rendering: Components consuming the updated state will re   render.

Global State Management

Global UI State: Redux is suitable for managing non   remote state (state not fetched from a server).
Remote State Alternatives: Tools like React Query, SWR, or Redux Toolkit Query are better for managing remote state.

Redux Mechanics

Dispatching Actions: Actions are dispatched to the store, not directly to reducers.
Store: Centralized location for all global state and reducers.
Multiple Reducers: Different reducers for different application features or data domains.

Action Creators

Purpose: Automate the process of writing actions, keeping all actions centralized.
Optional: Not a feature of Redux but a common practice in real   world apps.

Redux Cycle

1. Action Creator: Called in a component to generate an action.
2. Dispatch: The action is dispatched to the store.
3. Reducer: The appropriate reducer updates the state.
4. Re   render: UI components consuming the state re   render.

Bank Analogy

Action Creator: You (the person giving instructions).
Action: The instructions themselves.
Dispatcher: The bank teller (person at the desk).
Redux Store: The bank vault (holds the money/state).

Writing Redux Code in Isolation

1. Create Store File:
        In the `src` folder, create a new file named `store.js`.
2. Model the Initial State:
        Define the initial state for the application:	
        const initialState = {
          balance: 0,
          loan: 0,
          loanPurpose: ''
        };
        
3. Define the Reducer Function:
        Create a reducer function that calculates the new state based on the current state and the action received.
        Set the initial state as the default parameter for the state in the reducer function
        function reducer(state = initialState, action) {
          switch (action.type) {
            case "account/deposit":
              return { ...state, balance: state.balance + action.payload };
        
            case "account/withdraw":
              return { ...state, balance: state.balance     action.payload };
        
            case "account/requestLoan":
              if (state.loan > 0) return state;
              return {
                ...state,
                loan: action.payload.amount,
                loanPurpose: action.payload.purpose,
                balance: state.balance + action.payload.amount,
              };
        
            case "account/payLoan":
              return {
                ...state,
                loan: 0,
                loanPurpose: "",
                balance: state.balance     state.loan,
              };
        
            default:
              return state;
          }
        }
 
        
    
Creating the Redux Store
    
   Now that we have our initial state and reducer set up, let's create the Redux store. This involves a few steps, including installing Redux, creating the store, dispatching actions, and viewing the state changes.
    
Step   by   Step Guide
   1. Install Redux:
            Open your terminal and navigate to your project directory.
            Run the following command to install Redux:
            npm install redux

   2. Create the Store:
            In your `store.js` file, import `createStore` from Redux and create the store using your reducer:
            
            import { createStore } from 'redux';
            import reducer from './reducer';  // Assuming your reducer is in reducer.js
            
            // Create the store
            const store = createStore(reducer);
            
            // Export the store
            export default store;

   3. Dispatch Actions and Log State:
            To test the store, dispatch some actions and log the state:
            
            // Dispatch actions
            store.dispatch({ type: 'account/deposit', payload: 500 });
            console.log(store.getState()); // Should show balance: 500
            
            store.dispatch({ type: 'account/withdraw', payload: 200 });
            console.log(store.getState()); // Should show balance: 300
            
            store.dispatch({
              type: 'account/requestLoan',
              payload: { amount: 1000, purpose: 'buy a car' }
            });
            console.log(store.getState()); // Should show loan: 1000, loanPurpose: 'buy a car', balance: 1300
            
            store.dispatch({ type: 'account/payLoan' });
            console.log(store.getState()); // Should reset loan and loanPurpose, adjust balance
            
   4. Run and Test the Application:
            Modify `index.js` to import and execute the `store.js` file:
            
            import './store'; // This will run the code in store.js
            
            
Redux Action Creators

What are Action Creators?

    Action creators are simply functions that return actions.
    They are not strictly necessary for Redux to work but are a useful convention.
    Action creators make the code more reusable and help avoid mistakes like typos in action types.

Creating Action Creators

1. Defining Action Creators:
        Each possible action will have a corresponding action creator function.
        Example actions: `deposit`, `withdraw`, `requestLoan`, `payLoan`.
2. Action Creator Function:
        The function returns an action object.
        Example:
        
        const deposit = (amount) => {
            return {
                type: 'ACCOUNT_DEPOSIT',
                amount: amount
            };
        };
        
        
3. Using Action Creators:
        Instead of directly dispatching action objects, call the action creator functions.
        Example:
        store.dispatch(deposit(100));
        
        
4. Example Action Creators:
    
    const withdraw = (amount) => {
        return {
            type: 'ACCOUNT_WITHDRAW',
            amount: amount
        };
    };
    
    const requestLoan = (amount, purpose) => {
        return {
            type: 'REQUEST_LOAN',
            amount: amount,
            purpose: purpose
        };
    };
    
    const payLoan = () => {
        return {
            type: 'ACCOUNT_PAYLOAN'
        };
    };
         
    

Benefits of Using Action Creators

    Reusability: Makes code more reusable.
    Avoid Errors: Reduces the risk of typos and incorrect action types.

Handling Older Code Bases

    Older React codebases may use separate variables for action type strings.
    Example:
    
            
    const ACCOUNT_DEPOSIT = 'ACCOUNT_DEPOSIT';
         
    
    This practice is not commonly used in modern React but is important to be aware of.

    Modern Practice

    In modern React, it is more common to directly use strings in the action creators as shown in the examples.

   Redux: Adding Customer State and Combining Reducers

    Setting Up Initial State and Action Creators

1.   Initial State Setup:  
        Start by defining initial states for both `account` and `customer`.
        Example:
        
                
        const initialStateAccount = { ... };
        const initialStateCustomer = {
            fullName: '',
            nationalID: '',
            createdAt: ''
        };
             
        
2.   Creating Action Creators:  
          Create Customer Action Creator:  
            Takes `fullName` and `nationalID` as parameters.
            The `createdAt` field is generated within the action creator to avoid side effects in the reducer.
        
                
        const createCustomer = (fullName, nationalID) => {
            return {
                type: 'customer/createCustomer',
                payload: {
                    fullName,
                    nationalID,
                    createdAt: new Date().toISOString()
                }
            };
        };
             
        
          Update Name Action Creator:  
            Updates the customerâ€™s full name.
        
                
        const updateName = (fullName) => {
            return {
                type: 'customer/updateName',
                payload: fullName
            };
        };
             
        

    Creating the Reducer for Customer State

1.   Customer Reducer:  
        Handles `createCustomer` and `updateName` actions.
        Example:
        
                
        const customerReducer = (state = initialStateCustomer, action) => {
            switch (action.type) {
                case 'customer/createCustomer':
                    return {
                        ...state,
                        fullName: action.payload.fullName,
                        nationalID: action.payload.nationalID,
                        createdAt: action.payload.createdAt
                    };
                case 'customer/updateName':
                    return {
                        ...state,
                        fullName: action.payload
                    };
                default:
                    return state;
            }
        };
             
        
2.   Account Reducer:  
        Rename your previous reducer to `accountReducer` to differentiate it from the new `customerReducer`.

    Combining Reducers

1.   Root Reducer:  
        Combine multiple reducers into a single root reducer using Reduxâ€™s `combineReducers` function.
        Example:
        
                
        import { combineReducers } from 'redux';
        
        const rootReducer = combineReducers({
            account: accountReducer,
            customer: customerReducer
        });
             
        
2.   Store Setup:  
        Use the root reducer to create the Redux store.
    
            
    const store = createStore(rootReducer);
         
    

    Dispatching Actions and Updating State

1.   Dispatching Create Customer Action:  
        Example:
        
                
        store.dispatch(createCustomer('John Doe', '123456789'));
             
        
2.   Checking State:  
        Use `store.getState()` to check if the state updates correctly.
3.   Dispatching Account Actions:  
        Continue to dispatch actions for the account, like deposits, and observe how Redux handles both account and customer state separately.

    Key Takeaways

      Action Creators:   Useful for handling complex payloads and avoiding side effects in reducers.
      Reducers:   Should be pure functions without side effects.
      Combining Reducers:   Helps manage different slices of state efficiently.
      Redux Conventions:   Naming conventions and structured reducers make code more maintainable and understandable.

   Organizing Redux Code with State Slices

Let's reorganize the Redux code into a more modern and professional file structure using state slices.

    Step   by   Step Breakdown:

1.   Create Feature Folders:  
        Create a folder for each feature within a `features` directory.
        Example: `features/account` and `features/customers`.
2.   Organize Components:  
        Move components into their respective feature folders.
        Update imports in the main application file (e.g., `App.js`).
3.   Create Slice Files:  
        For each feature, create a slice file containing the initial state, action creators, and reducer.
        Example: `accountSlice.js` and `customerSlice.js` within their respective feature folders.
4.   Export Reducers and Action Creators:  
        Use default export for reducers and named exports for action creators in each slice file.
5.   Combine Reducers:  
        Import the reducers into the store file and combine them using `combineReducers`.
        Create the store using the combined reducer.
6.   Update Store Import:  
        Import the store in the main entry file (e.g., `index.js`).

    Implementation

    1. Directory Structure:

     
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ account/
â”‚   â”‚   â”œâ”€â”€ accountSlice.js
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ AccountOperations.js
â”‚   â”‚       â””â”€â”€ BalanceDisplay.js
â”‚   â”œâ”€â”€ customers/
â”‚   â”‚   â”œâ”€â”€ customerSlice.js
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ CreateCustomer.js
â”‚   â”‚       â””â”€â”€ CustomerInfo.js
â”œâ”€â”€ store/
â”‚   â””â”€â”€ store.js
â””â”€â”€ App.js

     

    2. Account Slice (`accountSlice.js`):

        
// features/account/accountSlice.js
const initialStateAccount = {
    balance: 0
};

export const deposit = (amount) => ({
    type: 'account/deposit',
    payload: amount
});

export const withdraw = (amount) => ({
    type: 'account/withdraw',
    payload: amount
});

const accountReducer = (state = initialStateAccount, action) => {
    switch (action.type) {
        case 'account/deposit':
            return { ...state, balance: state.balance + action.payload };
        case 'account/withdraw':
            return { ...state, balance: state.balance     action.payload };
        default:
            return state;
    }
};

export default accountReducer;

     

    3. Customer Slice (`customerSlice.js`):

        
// features/customers/customerSlice.js
const initialStateCustomer = {
    fullName: '',
    nationalID: '',
    createdAt: ''
};

export const createCustomer = (fullName, nationalID) => ({
    type: 'customer/createCustomer',
    payload: {
        fullName,
        nationalID,
        createdAt: new Date().toISOString()
    }
});

export const updateName = (fullName) => ({
    type: 'customer/updateName',
    payload: fullName
});

const customerReducer = (state = initialStateCustomer, action) => {
    switch (action.type) {
        case 'customer/createCustomer':
            return {
                ...state,
                ...action.payload
            };
        case 'customer/updateName':
            return {
                ...state,
                fullName: action.payload
            };
        default:
            return state;
    }
};

export default customerReducer;

     

    4. Store (`store.js`):

        
// store/store.js
import { createStore, combineReducers } from 'redux';
import accountReducer from '../features/account/accountSlice';
import customerReducer from '../features/customers/customerSlice';

const rootReducer = combineReducers({
    account: accountReducer,
    customer: customerReducer
});

const store = createStore(rootReducer);

export default store;

     

    5. Update Imports in `App.js`:

        
// App.js
import React from 'react';
import AccountOperations from './features/account/components/AccountOperations';
import BalanceDisplay from './features/account/components/BalanceDisplay';
import CreateCustomer from './features/customers/components/CreateCustomer';
import CustomerInfo from './features/customers/components/CustomerInfo';

function App() {
    return (
        <div>
            <AccountOperations />
            <BalanceDisplay />
            <CreateCustomer />
            <CustomerInfo />
        </div>
    );
}

export default App;

     

    6. Import and Use Store in `index.js`:

        
// index.js
import React from 'react';
import ReactDOM from 'react   dom';
import { Provider } from 'react   redux';
import App from './App';
import store from './store/store';

ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
);

     

    Summary

By organizing Redux code into state slices and feature folders, the structure becomes cleaner, more modular, and easier to maintain. This approach also minimizes the need to jump between files, enhancing the development experience. This structure sets a solid foundation for scaling the application efficiently.

   Connecting Redux Store with React Application

To connect the Redux store with a React application, follow these steps:

    1. Install React Redux:

First, you need to install the `react   redux` package.

     bash
npm install react   redux
     

    2. Provide the Store to the Application:

Wrap your application in the `Provider` component from `react   redux` and pass the store to it.

        
// index.js
import React from 'react';
import ReactDOM from 'react   dom';
import { Provider } from 'react   redux';
import App from './App';
import store from './store/store';

ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
);
     

This step ensures that the Redux store is available to all components in the application, similar to how the Context API works.

    3. Reading State with `useSelector` Hook:

To read data from the Redux store, use the `useSelector` hook from `react   redux`.

        
// features/customers/components/CustomerInfo.js
import React from 'react';
import { useSelector } from 'react   redux';

const CustomerInfo = () => {
    // Using useSelector to read data from the Redux store
    const customerName = useSelector((store) => store.customer.fullName);

    return (
        <div>
            <h1>Welcome, {customerName || "no one"}</h1>
        </div>
    );
};

export default CustomerInfo;
     

The `useSelector` hook takes a callback function that receives the entire Redux store as an argument and returns the desired state slice.

   Dispatching Actions in Redux with React Components

Now that we've connected our Redux store to our React application and learned how to read from it, let's explore how to dispatch actions from within React components. We'll start by working on the `CreateCustomer` component to dispatch actions and create a new customer.

    1. Setting Up the `CreateCustomer` Component

First, let's complete the `handleClick` function to dispatch an action when creating a new customer.

    Component Code:

        
// features/customers/components/CreateCustomer.js
import React, { useState } from 'react';
import { useDispatch } from 'react   redux';
import { createCustomer } from '../customerSlice';

const CreateCustomer = () => {
    const [fullName, setFullName] = useState('');
    const [nationalID, setNationalID] = useState('');
    const dispatch = useDispatch();

    const handleClick = () => {
        if (!fullName || !nationalID) return;
        dispatch(createCustomer(fullName, nationalID));
        setFullName('');
        setNationalID('');
    };

    return (
        <div>
            <input
                type="text"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                placeholder="Full Name"
            />
            <input
                type="text"
                value={nationalID}
                onChange={(e) => setNationalID(e.target.value)}
                placeholder="National ID"
            />
            <button onClick={handleClick}>CREATE NEW CUSTOMER</button>
        </div>
    );
};

export default CreateCustomer;
     

1.   useDispatch Hook  : We use the `useDispatch` hook from `react   redux` to get the `dispatch` function.
2.   Dispatching an Action  : Inside `handleClick`, we check if the required fields are filled, and if so, we dispatch the `createCustomer` action with the provided `fullName` and `nationalID`.

    2. Conditional Rendering in `App.js`

Next, let's modify `App.js` to conditionally render the `CreateCustomer` component or other components based on whether a customer exists.

    Component Code:

        
// App.js
import React from 'react';
import { useSelector } from 'react   redux';
import AccountOperations from './features/account/components/AccountOperations';
import BalanceDisplay from './features/account/components/BalanceDisplay';
import CreateCustomer from './features/customers/components/CreateCustomer';
import CustomerInfo from './features/customers/components/CustomerInfo';

function App() {
    const fullName = useSelector((state) => state.customer.fullName);

    return (
        <div>
            {fullName === '' ? (
                <CreateCustomer />
            ) : (
                <>
                    <CustomerInfo />
                    <BalanceDisplay />
                    <AccountOperations />
                </>
            )}
        </div>
    );
}

export default App;
     

1.   useSelector Hook  : We use the `useSelector` hook to get the `fullName` from the `customer` state.
2.   Conditional Rendering  : Based on whether `fullName` is an empty string, we conditionally render the `CreateCustomer` component or the other components.

    3. Dispatching Actions for Account Operations

Let's also update the `AccountOperations` component to dispatch actions for account   related operations.

    Component Code:

        
// features/account/components/AccountOperations.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react   redux';
import { deposit, withdraw, requestLoan, payLoan } from '../accountSlice';

const AccountOperations = () => {
    const dispatch = useDispatch();
    const [depositAmount, setDepositAmount] = useState('');
    const [withdrawAmount, setWithdrawAmount] = useState('');
    const [loanAmount, setLoanAmount] = useState('');
    const [loanPurpose, setLoanPurpose] = useState('');
    const account = useSelector((state) => state.account);

    const handleDeposit = () => {
        if (!depositAmount) return;
        dispatch(deposit(depositAmount));
        setDepositAmount('');
    };

    const handleWithdraw = () => {
        if (!withdrawAmount) return;
        dispatch(withdraw(withdrawAmount));
        setWithdrawAmount('');
    };

    const handleRequestLoan = () => {
        if (!loanAmount || !loanPurpose) return;
        dispatch(requestLoan(loanAmount, loanPurpose));
        setLoanAmount('');
        setLoanPurpose('');
    };

    const handlePayLoan = () => {
        dispatch(payLoan());
    };

    return (
        <div>
            <div>
                <input
                    type="text"
                    value={depositAmount}
                    onChange={(e) => setDepositAmount(e.target.value)}
                    placeholder="Deposit Amount"
                />
                <button onClick={handleDeposit}>Deposit</button>
            </div>
            <div>
                <input
                    type="text"
                    value={withdrawAmount}
                    onChange={(e) => setWithdrawAmount(e.target.value)}
                    placeholder="Withdraw Amount"
                />
                <button onClick={handleWithdraw}>Withdraw</button>
            </div>
            <div>
                <input
                    type="text"
                    value={loanAmount}
                    onChange={(e) => setLoanAmount(e.target.value)}
                    placeholder="Loan Amount"
                />
                <input
                    type="text"
                    value={loanPurpose}
                    onChange={(e) => setLoanPurpose(e.target.value)}
                    placeholder="Loan Purpose"
                />
                <button onClick={handleRequestLoan}>Request Loan</button>
            </div>
            <button onClick={handlePayLoan}>Pay Loan</button>
        </div>
    );
};

export default AccountOperations;
     

1.   Deposit, Withdraw, Request Loan, and Pay Loan  : Each function dispatches the corresponding action after validating the input.
2.   State Reset  : After dispatching, we reset the input fields to their initial state.

    Summary

By completing these steps, you have learned how to dispatch actions to the Redux store from within React components. This process involves using the `useDispatch` hook to get the `dispatch` function and then using it to dispatch actions created by action creators. The integration of these actions into your components allows for a dynamic and responsive UI that reacts to changes in the global state managed by Redux.

   Connecting React Components to Redux Store Using the Old `connect` API

    Overview:

In this lecture, the instructor introduces the old way of connecting React components to the Redux store using the `connect` API, which was prevalent before the advent of React hooks.

    Key Points:

1.   `useSelector` and `useDispatch` Hooks:  
        The modern approach to connecting React components to the Redux store is through the `useSelector` and `useDispatch` hooks.
        These hooks are simpler and more intuitive to use compared to the older `connect` API.
2.   The `connect` API:  
        Before React hooks, the `connect` function from the React Redux library was used to connect components to the Redux store.
        This function is still seen in older codebases and can be useful to know for maintaining legacy code.
3.   `mapStateToProps` Function:  
        `mapStateToProps` is a function that maps the Redux state to props for the component.
        It receives the state object from the Redux store and returns an object where the keys become props in the connected component.
4.   Implementing `connect` in a Component:  
        In the `BalanceDisplay` component, the instructor demonstrates how to use the `connect` function:
            `mapStateToProps` function is defined to extract the `balance` from the Redux state.
            The `connect` function is used to pass `mapStateToProps` and wrap the component, which injects the `balance` prop.
            The `balance` prop is then used to display the formatted balance in the UI.
5.   Key Differences:  
        The `connect` API is more complex and less intuitive compared to the modern hooks approach.
        Understanding `connect` is useful for working with legacy code, but in modern development, hooks are preferred.
6.   Practical Example:  
        The instructor shows a practical example where the balance is displayed and updated when deposit actions are dispatched.
        The example highlights the old way of doing things while reinforcing the concept of connecting React components to Redux.
7.   Conclusion:  
        The instructor concludes by mentioning that while the `connect` API is less commonly used today, it's important to be familiar with it for older codebases.
        The next lecture will introduce Redux Middleware and Thunks, which handle asynchronous operations like data fetching.

        
// BalanceDisplay.js

import React from 'react';
import { connect } from 'react   redux';
import formatCurrency from './formatCurrency'; // Assume this is a utility function to format currency

// mapStateToProps function
const mapStateToProps = (state) => {
  return {
    balance: state.account.balance, // Map the balance from the Redux state to the balance prop
  };
};

// BalanceDisplay component
const BalanceDisplay = ({ balance }) => {
  return (
    <div>
      <h2>Current Balance</h2>
      <p>{formatCurrency(balance)}</p> {/* Use the balance prop to display the formatted balance */}
    </div>
  );
};

// Connect the BalanceDisplay component to the Redux store
export default connect(mapStateToProps)(BalanceDisplay);
     

   Implementing Middleware in Redux with Redux Thunk

In this lecture, we explore how to use Middleware in Redux to handle asynchronous operations like API calls. Specifically, we'll focus on using   Redux Thunk   to fetch data asynchronously before dispatching actions to the Redux store.

    Why Middleware?

      Reducers   in Redux must be pure functions, meaning they can't have side effects like asynchronous API calls.
    Performing asynchronous operations directly in components is possible but not ideal, as it can lead to scattered data   fetching logic and less clean components.
      Middleware   acts as an intermediary between dispatching an action and reaching the reducer, making it the perfect place for handling side effects.

    Redux Thunk

      Redux Thunk   is a popular middleware that allows us to write action creators that return a function instead of an action object.
    This function can perform asynchronous operations and dispatch actions conditionally, depending on the result of those operations.

![Untitled](https://prod   files   secure.s3.us   west   2.amazonaws.com/37a7a1ac   38c5   44da   9681   8c1e24cb5e50/d5f108d9   586b   4d3e   9f35   d1c1809b7193/Untitled.png)

![Untitled](https://prod   files   secure.s3.us   west   2.amazonaws.com/37a7a1ac   38c5   44da   9681   8c1e24cb5e50/e47db5fd   cae9   436d   91c7   5553de9a1718/Untitled.png)

   Redux Thunks

      1. Introduction to Redux Middleware  

      Middleware in Redux:   Middleware is a function that sits between the action being dispatched and the reducer that updates the state in the Redux store. It allows you to intercept actions and perform additional operations before they reach the reducer.
      Use Case for Middleware:   Middleware is especially useful for handling side effects like asynchronous API calls, logging, or modifying actions. Since reducers need to be pure functions with no side effects, middleware is the appropriate place for these operations.

      2. What is Redux Thunk?  

      Redux Thunk Overview:   Redux Thunk is a popular middleware that allows you to write action creators that return a function instead of an action. This function can include asynchronous logic, and it delays dispatching the action until the operation is complete.
      Basic Thunk Functionality:  
        Thunks allow you to perform asynchronous tasks (e.g., API calls) within your action creators.
        The thunk function has access to the `dispatch` function and the current `state` via `getState`, enabling you to dispatch actions conditionally or based on the results of asynchronous operations.

      3. Setting Up Redux Thunk  

      Step 1: Install Redux Thunk  
    
         bash
    npm install redux   thunk
         
    
      Step 2: Apply Thunk Middleware to the Redux Store  
    
            
    import { createStore, applyMiddleware } from 'redux';
    import thunk from 'redux   thunk';
    import rootReducer from './reducers'; // Assuming you have a root reducer
    
    const store = createStore(rootReducer, applyMiddleware(thunk));
         
    
        Here, `applyMiddleware(thunk)` is used to apply the thunk middleware to the Redux store, allowing the store to handle functions (thunks) in addition to plain action objects.

      4. Example Use Case: Currency Conversion on Deposit  

      Scenario:   When a user deposits money into an account in a foreign currency (e.g., Euros), the amount must be converted to USD using an external API before it is deposited into the account.
      Step 3: Modify Action Creator to Use Thunks  
          Initial Setup:  
            Let's say we have an action creator `deposit` that deposits money into the account.
            The action creator will now accept both the amount and the currency.
    
            
    // Action Creator with Thunk
    
    export function deposit(amount, currency) {
    	// Check if the currency is USD
      if (currency === "USD") {
    	  // Directly return the action object if currency is USD
        return {
          type: "account/deposit",
          payload: amount,
        };
      }
      
    	// If not USD, perform API call to convert currency
      return async function (dispatch, getState) {
        const res = await fetch(
          `https://api.frankfurter.app/latest?amount=${amount}&from=${currency}&to=USD`
        );
    
        const data = await res.json();
        const converted = data.rates.USD;
    
    		// Dispatch the action with the converted amount
        dispatch({
          type: "account/deposit",
          payload: converted,
        });
      };
    }
         
    
          Explanation:  
            If the currency is USD, the action is dispatched immediately with the amount.
            If the currency is not USD, a fetch request is made to an API to convert the amount to USD. Once the converted amount is received, it is dispatched as the payload.

      5. Enhancing User Experience with Loading State  

      Adding a Loading Indicator:  
        We can add a loading state (`isLoading`) to the Redux store to indicate when an asynchronous operation is in progress.
    
            
    // Initial State
    const initialState = {
      balance: 0,
      isLoading: false,
    };
    
    // Reducer
    const accountReducer = (state = initialState, action) => {
      switch (action.type) {
        case 'account/deposit':
          return {
            ...state,
            balance: state.balance + action.payload,
            isLoading: false, // Reset loading state
          };
        case 'account/convertingCurrency':
          return {
            ...state,
            isLoading: true, // Set loading state
          };
        default:
          return state;
      }
    };
         
    
      Dispatching Loading State Changes:  
        Before making the API call, dispatch an action to set `isLoading` to `true`.
    
            
    export function deposit(amount, currency) {
      if (currency === "USD") {
        return {
          type: "account/deposit",
          payload: amount,
        };
      }
      
      return async function (dispatch, getState) {
    	  // Dispatch action to set loading state
        dispatch({ type: "account/convertingCurrency" });
    
        const res = await fetch(
          `https://api.frankfurter.app/latest?amount=${amount}&from=${currency}&to=USD`
        );
    
        const data = await res.json();
        const converted = data.rates.USD;
    
        dispatch({
          type: "account/deposit",
          payload: converted,
        });
      };
    }
         
    
      Using the Loading State in the Component:  
        The loading state can be used to disable the deposit button and show a loading message.
    
            
    const DepositButton = () => {
      const dispatch = useDispatch();
      const isLoading = useSelector((state) => state.account.isLoading);
    
      const handleDeposit = () => {
        dispatch(deposit(100, 'EUR'));
      };
    
      return (
        <button onClick={handleDeposit} disabled={isLoading}>
          {isLoading ? 'Converting...' : 'Deposit'}
        </button>
      );
    };
         
    
          Explanation:  
            The button is disabled when `isLoading` is `true`, and it shows "Converting..." while the API call is in progress.

      6. Benefits of Using Thunks in Redux  

      Encapsulation of Asynchronous Logic:   Thunks allow you to keep your components free from asynchronous logic, centralizing it within the Redux slice.
      Clean Components:   By using thunks, your components remain clean and focused on UI logic, without needing to worry about data fetching or other side effects.
      Delayed Dispatching:   Thunks provide the ability to delay dispatching actions until after asynchronous operations are complete, ensuring that your state is only updated with the final results.

      Conclusion:  

Redux Thunks offer a powerful way to handle asynchronous actions in Redux. By returning functions instead of action objects, you can perform tasks like API calls and dispatch actions only when needed. This leads to cleaner, more maintainable code and a better separation of concerns within your application.

   Redux Dev Tools: Installation and Usage

Redux provides powerful developer tools similar to React Dev Tools, which can significantly enhance your development workflow by allowing you to inspect and debug the state changes in your Redux store.

    Step 1: Install the Redux DevTools Chrome Extension

First, install the   Redux DevTools   extension from the Chrome Web Store. This extension will allow you to visualize and interact with your Redux store directly from the browser.

1. Search for "Redux DevTools" in the Chrome Web Store.
2. Install the extension.

    Step 2: Install the Redux DevTools NPM Package

Next, install the corresponding NPM package to integrate Redux DevTools with your project.

     bash
npm install @redux   devtools/extension
     

This package provides a function called `composeWithDevTools`, which you will use to enhance your Redux store.

    Step 3: Configure Redux Store with DevTools

You need to wrap your `applyMiddleware` function with `composeWithDevTools` when creating the Redux store. This allows Redux DevTools to interact with your store.

        
import { createStore, applyMiddleware } from 'redux';
import { composeWithDevTools } from 'redux   devtools   extension';
import rootReducer from './reducers'; // Assuming you have a root reducer

const store = createStore(
  rootReducer,
  composeWithDevTools(
    applyMiddleware(/* your middleware here */)
  )
);
     

With this setup, Redux DevTools will now be able to monitor the actions dispatched and the state changes in your Redux store.

    Using Redux DevTools

After setting up, you can use Redux DevTools to inspect actions, state, and even time travel through different states.

1.   Dispatching Actions  : When you dispatch an action, you can see it in the "Actions" tab of Redux DevTools. It shows the action type, payload, and the resulting state.
    
            
    store.dispatch({ type: 'customer/createCustomer', payload: { name: 'John Doe', id: 1 } });
         
    
    This will display:
    
          Action Type  : `customer/createCustomer`
          Payload  : `{ name: 'John Doe', id: 1 }`
          New State  : Updated state after the action is processed.
2.   Inspecting State Changes  : For each action, you can see the state before and after the action was dispatched. This helps in understanding how your reducers are working.
3.   Time Travel Debugging  : One of the coolest features of Redux DevTools is the ability to "time travel" between different state transitions. You can jump to any previous state by clicking on the corresponding action in the dev tools.
          Jump to State  : Select a previous action to revert the store to the state at that time.
          Slider  : Use the slider to smoothly transition between different states.
4.   Manual Action Dispatching  : Redux DevTools allows you to manually dispatch actions without modifying your UI. This is useful for testing how certain actions affect your state.
    
            
    // Manually dispatching an action in Redux DevTools
    store.dispatch({ type: 'customer/updateName', payload: { name: 'Jane Doe' } });
         
    

    Example: Debugging with Redux DevTools

Suppose you encounter a bug where a currency conversion is incorrectly triggered during a deposit action. Using Redux DevTools, you can trace the actions leading up to the bug.

1.   Identify the Issue  : In the dev tools, notice that the action `account/convertingCurrency` is dispatched when it shouldnâ€™t be.
2.   Inspect the Code  : You find that the problem is due to resetting the currency to an empty string instead of `USD` after the first deposit.
3.   Fix the Bug  : Update the code to ensure the currency is correctly set after each deposit.
    
            
    // Fix the currency reset issue
    const deposit = (amount) => {
      dispatch({ type: 'account/deposit', payload: amount });
      setCurrency('USD'); // Reset to USD after deposit
    };
         
    
4.   Verify the Fix  : After making the change, use Redux DevTools to dispatch the deposit action again and confirm that the bug is resolved.

    Conclusion

Redux DevTools are an essential tool for debugging and understanding your Redux store's state management. By visualizing the state changes and actions, you can quickly identify issues and ensure your application behaves as expected.

   Introduction to Redux Toolkit

Redux Toolkit (RTK) is the recommended approach for writing Redux logic, offering a more efficient, modern, and opinionated way to manage state in React applications. The Redux team now advises using Redux Toolkit over classic Redux due to its numerous advantages.

![Untitled](https://prod   files   secure.s3.us   west   2.amazonaws.com/37a7a1ac   38c5   44da   9681   8c1e24cb5e50/65a051f9   da00   4d45   8c28   f75b0051439f/Untitled.png)

    Why Redux Toolkit?

      Reduced Boilerplate  : One of the most significant benefits of Redux Toolkit is the drastic reduction in boilerplate code. Tasks such as setting up middleware, creating action creators, and configuring the Redux DevTools are simplified or handled automatically.
      Best Practices  : Redux Toolkit encapsulates the best practices learned by the Redux community, promoting consistency and reliability in your Redux codebase.
      Mutating State in Reducers  : With Redux Toolkit, you can write reducers that appear to mutate the state directly. Behind the scenes, Redux Toolkit uses a library called   Immer   to ensure the immutability of the state, making the code simpler and reducing complexity, especially with nested objects and arrays.
      Automatic Action Creators  : Redux Toolkit automatically generates action creators based on the reducers you define, further reducing the amount of code you need to write.
      Integrated Thunk Middleware  : Redux Toolkit comes with built   in support for asynchronous logic via   Thunk   middleware, removing the need to set it up manually.

    Compatibility with Classic Redux

While Redux Toolkit introduces a modern way to write Redux, it is fully compatible with classic Redux. This means you can mix and match both approaches within the same application if needed.

    Key Features of Redux Toolkit

1.   Simplified Reducers with Immer  :
        You can write reducers that appear to directly mutate the state, simplifying your code, especially when dealing with complex or nested state objects.
2.   Automatic Action Creators  :
        Redux Toolkit generates action creators based on the reducers you define within a slice, reducing the need for manual creation.
3.   Thunk Middleware and DevTools Setup  :
        Redux Toolkit automatically includes Thunk middleware and configures the Redux DevTools, allowing you to focus on writing business logic rather than setup code.

   Converting the Store to Redux Toolkit

Redux Toolkit simplifies the process of setting up a Redux store by providing utilities that automatically handle much of the configuration. Let's walk through the process of converting an existing Redux store to use Redux Toolkit.

    Step 1: Installing Redux Toolkit

First, install Redux Toolkit by running the following command:

     bash
npm install @reduxjs/toolkit
     

Redux Toolkit is part of the `@reduxjs` namespace, which allows the Redux team to publish multiple related packages under the same umbrella.

    Step 2: Replacing `createStore` with `configureStore`

Redux Toolkit introduces a new function called `configureStore`, which wraps around the traditional `createStore` method and adds several helpful features automatically, such as:

    Combining reducers
    Adding the Thunk middleware by default
    Setting up the Redux DevTools extension

Here's how to convert an existing store setup to use `configureStore`.

1.   Import `configureStore`   from Redux Toolkit:
    
            
    import { configureStore } from '@reduxjs/toolkit';
         
    
2.   Set Up the Store  :
        Replace the old `createStore` method with `configureStore`.
        Pass an object to `configureStore` where you define the root reducer using the `reducer` property.
        The `reducer` property itself is an object that maps slice names to their respective reducer functions.
    
            
    import accountReducer from './accountSlice';
    import customerReducer from './customerSlice';
    
    const store = configureStore({
      reducer: {
        account: accountReducer,
        customer: customerReducer,
      },
    });
    
    export default store;
         
    
3.   Clean Up  :
        Remove the old imports and code related to `createStore` and middleware setup, as `configureStore` handles them automatically.
    
            
    // Before: Old store setup with createStore
    import { createStore, applyMiddleware, combineReducers } from 'redux';
    import thunk from 'redux   thunk';
    import { composeWithDevTools } from 'redux   devtools   extension';
    import accountReducer from './accountSlice';
    import customerReducer from './customerSlice';
    
    const rootReducer = combineReducers({
      account: accountReducer,
      customer: customerReducer,
    });
    
    const store = createStore(
      rootReducer,
      composeWithDevTools(applyMiddleware(thunk))
    );
    
    export default store;
         
    
            
    // After: Simplified store setup with configureStore
    import { configureStore } from '@reduxjs/toolkit';
    import accountReducer from './accountSlice';
    import customerReducer from './customerSlice';
    
    const store = configureStore({
      reducer: {
        account: accountReducer,
        customer: customerReducer,
      },
    });
    
    export default store;
         
    

    Step 3: Gradual Upgrade

One of the powerful aspects of Redux Toolkit is that it's fully compatible with classic Redux. This means you can convert your store to use `configureStore` while keeping your existing slices and reducers unchanged. This gradual migration path allows you to adopt Redux Toolkit at your own pace.

    Step 4: Maintaining Application Compatibility

The connection between your React application and Redux remains unchanged. You will continue to use the `Provider` from `react   redux` to connect your store to your React app:

        
import React from 'react';
import ReactDOM from 'react   dom';
import { Provider } from 'react   redux';
import App from './App';
import store from './store';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
     

   Converting the Account State Slice to Redux Toolkit

    1.   Introduction to `createSlice`  

      Redux Toolkit   provides a `createSlice` function that simplifies the process of creating action creators and reducers.
      Benefits  :
        Automatically creates action creators from reducers.
        Simplifies writing reducers (no need for switch statements).
        Allows for state mutation inside reducers while still maintaining immutability behind the scenes using the Immer library.

    2.   Initial Setup  

    Import the `createSlice` function from Redux Toolkit:
    
            
    import { createSlice } from '@reduxjs/toolkit';
         
    
    Define the `initialState` as you would normally.

    3.   Creating the Slice  

    Use `createSlice` to generate the slice:
    
            
    const accountSlice = createSlice({
      name: 'account',
      initialState,
      reducers: {
        deposit: (state, action) => {
          state.balance += action.payload;
        },
        withdraw: (state, action) => {
          state.balance    = action.payload;
        },
        requestLoan: {
          reducer: (state, action) => {
            if (state.loan === 0) {
              state.loan = action.payload.amount;
              state.loanPurpose = action.payload.purpose;
              state.balance += action.payload.amount;
            }
          },
          prepare: (amount, purpose) => ({
            payload: { amount, purpose }
          })
        },
        payLoan: (state) => {
          state.balance    = state.loan;
          state.loan = 0;
          state.loanPurpose = '';
        },
      },
    });
         
    
      Explanation  :
        The slice is named `'account'`.
        The `initialState` is defined as usual.
        Reducers like `deposit`, `withdraw`, `requestLoan`, and `payLoan` handle the respective actions.
        `requestLoan` includes a `prepare` method to handle multiple arguments.

    4.   Exporting the Slice  

    Export the reducer and actions:
    
            
    export const { deposit, withdraw, requestLoan, payLoan } = accountSlice.actions;
    export default accountSlice.reducer;
         
    

    5.   Testing the New Slice  

    Ensure that the store is properly configured to use this new slice.
    Test the actions to confirm they work as expected:
    
            
    store.dispatch(deposit(1000));
    store.dispatch(withdraw(500));
    store.dispatch(requestLoan(10000, 'Car Purchase'));
    store.dispatch(payLoan());
         
    

    6.   Understanding Limitations  

    By default, action creators created by `createSlice` accept only one argument (which becomes `action.payload`).
    The `prepare` method can be used to handle cases where multiple arguments are needed.
    The mutating logic requires careful attention to the order of operations within reducers.

    7.   Conclusion  

      Redux Toolkit   offers a more streamlined way to handle Redux logic, but it comes with trade   offs.
    Deciding whether to use the traditional method or Redux Toolkit should be based on the specific needs of the project.